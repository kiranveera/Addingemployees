{"version":3,"sources":["D:/angularprojects/Employeesadding/node_modules/@ngx-formly/core/fesm2015/ngx-formly-core.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6jBC,uHAGC;;;;;gDACuL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2HxL,sIAGC;;;;;;;;;;;4IAOmR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8RpR,+FAkBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsOD,4BAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8PD,iHAUC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6IA8DD;;;;;;;AAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0DAiSD;;;;6EAGC;;;;;;;;;;;;;;;;;;;;;;;CAaD;;;;;;;;;;;;;;0BAYC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwDD,2EAOC;;;;;;;;;;;;;;;;;oBAOA;;;;;;;;;;;;;CAOD;;;;;;;;0BAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAk9BD,2NAeC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAKA","file":"ngx-formly-core.js","sourcesContent":["import { DOCUMENT, CommonModule } from '@angular/common';\nimport { debounceTime, switchMap, distinctUntilChanged, take, map, startWith } from 'rxjs/operators';\nimport { Injectable, InjectionToken, NgModule, ANALYZE_FOR_ENTRY_COMPONENTS, Inject, Optional, Component, Input, ChangeDetectionStrategy, EventEmitter, Output, Attribute, ViewChild, ElementRef, NgZone, ViewContainerRef, ComponentFactoryResolver, Renderer2, Directive, Injector, defineInjectable, inject, INJECTOR } from '@angular/core';\nimport { AbstractControl, FormGroup, FormGroupDirective, FormControl, FormArray, Validators } from '@angular/forms';\nimport { isObservable, Subject, Observable, of } from 'rxjs';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} formId\n * @param {?} field\n * @param {?} index\n * @return {?}\n */\nfunction getFieldId(formId, field, index) {\n    if (field.id)\n        return field.id;\n    /** @type {?} */\n    let type = field.type;\n    if (!type && field.template)\n        type = 'template';\n    return [formId, type, field.key, index].join('_');\n}\n/**\n * @param {?} field\n * @return {?}\n */\nfunction getKeyPath(field) {\n    if (!field.key) {\n        return [];\n    }\n    /* We store the keyPath in the field for performance reasons. This function will be called frequently. */\n    if (!field._keyPath || field._keyPath.key !== field.key) {\n        /** @type {?} */\n        const key = field.key.indexOf('[') === -1\n            ? field.key\n            : field.key.replace(/\\[(\\w+)\\]/g, '.$1');\n        field._keyPath = { key: field.key, path: key.indexOf('.') !== -1 ? key.split('.') : [key] };\n    }\n    return field._keyPath.path.slice(0);\n}\n/** @type {?} */\nconst FORMLY_VALIDATORS = ['required', 'pattern', 'minLength', 'maxLength', 'min', 'max'];\n/**\n * @param {?} model\n * @param {?} paths\n * @param {?} value\n * @return {?}\n */\nfunction assignModelValue(model, paths, value) {\n    for (let i = 0; i < (paths.length - 1); i++) {\n        /** @type {?} */\n        const path = paths[i];\n        if (!model[path] || !isObject(model[path])) {\n            model[path] = /^\\d+$/.test(paths[i + 1]) ? [] : {};\n        }\n        model = model[path];\n    }\n    model[paths[paths.length - 1]] = clone(value);\n}\n/**\n * @param {?} field\n * @return {?}\n */\nfunction getFieldInitialValue(field) {\n    /** @type {?} */\n    let value = field.options['_initialModel'];\n    /** @type {?} */\n    let paths = getKeyPath(field);\n    while (field.parent) {\n        field = field.parent;\n        paths = [...getKeyPath(field), ...paths];\n    }\n    for (const path of paths) {\n        if (!value) {\n            return undefined;\n        }\n        value = value[path];\n    }\n    return value;\n}\n/**\n * @param {?} field\n * @return {?}\n */\nfunction getFieldValue(field) {\n    /** @type {?} */\n    let model = field.parent.model;\n    for (const path of getKeyPath(field)) {\n        if (!model) {\n            return model;\n        }\n        model = model[path];\n    }\n    return model;\n}\n/**\n * @param {?} dest\n * @param {...?} args\n * @return {?}\n */\nfunction reverseDeepMerge(dest, ...args) {\n    args.forEach((/**\n     * @param {?} src\n     * @return {?}\n     */\n    src => {\n        for (let srcArg in src) {\n            if (isNullOrUndefined(dest[srcArg]) || isBlankString(dest[srcArg])) {\n                dest[srcArg] = clone(src[srcArg]);\n            }\n            else if (objAndSameType(dest[srcArg], src[srcArg])) {\n                reverseDeepMerge(dest[srcArg], src[srcArg]);\n            }\n        }\n    }));\n    return dest;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isNullOrUndefined(value) {\n    return value === undefined || value === null;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isUndefined(value) {\n    return value === undefined;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isBlankString(value) {\n    return value === '';\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isFunction(value) {\n    return typeof (value) === 'function';\n}\n/**\n * @param {?} obj1\n * @param {?} obj2\n * @return {?}\n */\nfunction objAndSameType(obj1, obj2) {\n    return isObject(obj1) && isObject(obj2)\n        && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2)\n        && !(Array.isArray(obj1) || Array.isArray(obj2));\n}\n/**\n * @param {?} x\n * @return {?}\n */\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction isPromise(obj) {\n    return !!obj && typeof obj.then === 'function';\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction clone(value) {\n    if (!isObject(value)\n        || isObservable(value)\n        || /* instanceof SafeHtmlImpl */ value.changingThisBreaksApplicationSecurity\n        || ['RegExp', 'FileList', 'File', 'Blob'].indexOf(value.constructor.name) !== -1) {\n        return value;\n    }\n    // https://github.com/moment/moment/blob/master/moment.js#L252\n    if (value._isAMomentObject && isFunction(value.clone)) {\n        return value.clone();\n    }\n    if (value instanceof AbstractControl) {\n        return null;\n    }\n    if (value instanceof Date) {\n        return new Date(value.getTime());\n    }\n    if (Array.isArray(value)) {\n        return value.slice(0).map((/**\n         * @param {?} v\n         * @return {?}\n         */\n        v => clone(v)));\n    }\n    // best way to clone a js object maybe\n    // https://stackoverflow.com/questions/41474986/how-to-clone-a-javascript-es6-class-instance\n    /** @type {?} */\n    const proto = Object.getPrototypeOf(value);\n    /** @type {?} */\n    let c = Object.create(proto);\n    c = Object.setPrototypeOf(c, proto);\n    // need to make a deep copy so we dont use Object.assign\n    // also Object.assign wont copy property descriptor exactly\n    return Object.keys(value).reduce((/**\n     * @param {?} newVal\n     * @param {?} prop\n     * @return {?}\n     */\n    (newVal, prop) => {\n        /** @type {?} */\n        const propDesc = Object.getOwnPropertyDescriptor(value, prop);\n        if (propDesc.get) {\n            Object.defineProperty(newVal, prop, propDesc);\n        }\n        else {\n            newVal[prop] = clone(value[prop]);\n        }\n        return newVal;\n    }), c);\n}\n/**\n * @param {?} field\n * @param {?} prop\n * @param {?} defaultValue\n * @return {?}\n */\nfunction defineHiddenProp(field, prop, defaultValue) {\n    Object.defineProperty(field, prop, { enumerable: false, writable: true, configurable: true });\n    field[prop] = defaultValue;\n}\n/**\n * @template T\n * @param {?} o\n * @param {?} prop\n * @param {?} setFn\n * @return {?}\n */\nfunction wrapProperty(o, prop, setFn) {\n    if (!o._observers) {\n        defineHiddenProp(o, '_observers', {});\n    }\n    if (!o._observers[prop]) {\n        o._observers[prop] = [];\n    }\n    /** @type {?} */\n    let fns = o._observers[prop];\n    if (fns.indexOf(setFn) === -1) {\n        fns.push(setFn);\n        setFn({ currentValue: o[prop], firstChange: true });\n        if (fns.length === 1) {\n            defineHiddenProp(o, `___$${prop}`, o[prop]);\n            Object.defineProperty(o, prop, {\n                configurable: true,\n                get: (/**\n                 * @return {?}\n                 */\n                () => o[`___$${prop}`]),\n                set: (/**\n                 * @param {?} currentValue\n                 * @return {?}\n                 */\n                currentValue => {\n                    if (currentValue !== o[`___$${prop}`]) {\n                        /** @type {?} */\n                        const previousValue = o[`___$${prop}`];\n                        o[`___$${prop}`] = currentValue;\n                        fns.forEach((/**\n                         * @param {?} changeFn\n                         * @return {?}\n                         */\n                        changeFn => changeFn({ previousValue, currentValue, firstChange: false })));\n                    }\n                }),\n            });\n        }\n    }\n    return (/**\n     * @return {?}\n     */\n    () => fns.splice(fns.indexOf(setFn), 1));\n}\n/**\n * @param {?} form\n * @param {?} action\n * @return {?}\n */\nfunction reduceFormUpdateValidityCalls(form, action) {\n    /** @type {?} */\n    const updateValidity = form._updateTreeValidity.bind(form);\n    /** @type {?} */\n    let updateValidityArgs = null;\n    form._updateTreeValidity = (/**\n     * @param {...?} args\n     * @return {?}\n     */\n    (...args) => updateValidityArgs = args);\n    action();\n    updateValidityArgs && updateValidity(updateValidityArgs);\n    form._updateTreeValidity = updateValidity;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst FORMLY_CONFIG = new InjectionToken('FORMLY_CONFIG');\n/**\n * Maintains list of formly field directive types. This can be used to register new field templates.\n */\nclass FormlyConfig {\n    constructor() {\n        this.types = {};\n        this.validators = {};\n        this.wrappers = {};\n        this.messages = {};\n        this.templateManipulators = {\n            preWrapper: [],\n            postWrapper: [],\n        };\n        this.extras = {\n            checkExpressionOn: 'changeDetectionCheck',\n            showError: (/**\n             * @param {?} field\n             * @return {?}\n             */\n            function (field) {\n                return field.formControl && field.formControl.invalid && (field.formControl.touched || (field.options.parentForm && field.options.parentForm.submitted) || (field.field.validation && field.field.validation.show));\n            }),\n        };\n        this.extensions = {};\n    }\n    /**\n     * @param {?} config\n     * @return {?}\n     */\n    addConfig(config) {\n        if (config.types) {\n            config.types.forEach((/**\n             * @param {?} type\n             * @return {?}\n             */\n            type => this.setType(type)));\n        }\n        if (config.validators) {\n            config.validators.forEach((/**\n             * @param {?} validator\n             * @return {?}\n             */\n            validator => this.setValidator(validator)));\n        }\n        if (config.wrappers) {\n            config.wrappers.forEach((/**\n             * @param {?} wrapper\n             * @return {?}\n             */\n            wrapper => this.setWrapper(wrapper)));\n        }\n        if (config.manipulators) {\n            console.warn(`NgxFormly: passing 'manipulators' config is deprecated, use custom extension instead.`);\n            config.manipulators.forEach((/**\n             * @param {?} manipulator\n             * @return {?}\n             */\n            manipulator => this.setManipulator(manipulator)));\n        }\n        if (config.validationMessages) {\n            config.validationMessages.forEach((/**\n             * @param {?} validation\n             * @return {?}\n             */\n            validation => this.addValidatorMessage(validation.name, validation.message)));\n        }\n        if (config.extensions) {\n            config.extensions.forEach((/**\n             * @param {?} c\n             * @return {?}\n             */\n            c => this.extensions[c.name] = c.extension));\n        }\n        if (config.extras) {\n            this.extras = Object.assign({}, this.extras, config.extras);\n        }\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    setType(options) {\n        if (Array.isArray(options)) {\n            options.forEach((/**\n             * @param {?} option\n             * @return {?}\n             */\n            (option) => this.setType(option)));\n        }\n        else {\n            if (!this.types[options.name]) {\n                this.types[options.name] = (/** @type {?} */ ({ name: options.name }));\n            }\n            ['component', 'extends', 'defaultOptions'].forEach((/**\n             * @param {?} prop\n             * @return {?}\n             */\n            prop => {\n                if (options.hasOwnProperty(prop)) {\n                    this.types[options.name][prop] = options[prop];\n                }\n            }));\n            if (options.wrappers) {\n                options.wrappers.forEach((/**\n                 * @param {?} wrapper\n                 * @return {?}\n                 */\n                (wrapper) => this.setTypeWrapper(options.name, wrapper)));\n            }\n        }\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    getType(name) {\n        if (!this.types[name]) {\n            throw new Error(`[Formly Error] There is no type by the name of \"${name}\"`);\n        }\n        this.mergeExtendedType(name);\n        return this.types[name];\n    }\n    /**\n     * @param {?=} field\n     * @return {?}\n     */\n    getMergedField(field = {}) {\n        /** @type {?} */\n        const type = this.getType(field.type);\n        if (type.defaultOptions) {\n            reverseDeepMerge(field, type.defaultOptions);\n        }\n        /** @type {?} */\n        const extendDefaults = type.extends && this.getType(type.extends).defaultOptions;\n        if (extendDefaults) {\n            reverseDeepMerge(field, extendDefaults);\n        }\n        if (field && field.optionsTypes) {\n            field.optionsTypes.forEach((/**\n             * @param {?} option\n             * @return {?}\n             */\n            option => {\n                /** @type {?} */\n                const defaultOptions = this.getType(option).defaultOptions;\n                if (defaultOptions) {\n                    reverseDeepMerge(field, defaultOptions);\n                }\n            }));\n        }\n        /** @type {?} */\n        const componentRef = this.resolveFieldTypeRef(field);\n        if (componentRef && componentRef.instance && componentRef.instance.defaultOptions) {\n            reverseDeepMerge(field, componentRef.instance.defaultOptions);\n        }\n        if (!field.wrappers && type.wrappers) {\n            field.wrappers = [...type.wrappers];\n        }\n    }\n    /**\n     * \\@internal\n     * @param {?=} field\n     * @return {?}\n     */\n    resolveFieldTypeRef(field = {}) {\n        if (!field.type) {\n            return null;\n        }\n        /** @type {?} */\n        const type = this.getType(field.type);\n        if (!type.component || type['_componentRef']) {\n            return type['_componentRef'];\n        }\n        const { _resolver, _injector } = field.parent.options;\n        defineHiddenProp(type, '_componentRef', _resolver.resolveComponentFactory(type.component).create(_injector));\n        return type['_componentRef'];\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    setWrapper(options) {\n        this.wrappers[options.name] = options;\n        if (options.types) {\n            options.types.forEach((/**\n             * @param {?} type\n             * @return {?}\n             */\n            (type) => {\n                this.setTypeWrapper(type, options.name);\n            }));\n        }\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    getWrapper(name) {\n        if (!this.wrappers[name]) {\n            throw new Error(`[Formly Error] There is no wrapper by the name of \"${name}\"`);\n        }\n        return this.wrappers[name];\n    }\n    /**\n     * @param {?} type\n     * @param {?} name\n     * @return {?}\n     */\n    setTypeWrapper(type, name) {\n        if (!this.types[type]) {\n            this.types[type] = (/** @type {?} */ ({}));\n        }\n        if (!this.types[type].wrappers) {\n            this.types[type].wrappers = [];\n        }\n        if (this.types[type].wrappers.indexOf(name) === -1) {\n            this.types[type].wrappers.push(name);\n        }\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    setValidator(options) {\n        this.validators[options.name] = options;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    getValidator(name) {\n        if (!this.validators[name]) {\n            throw new Error(`[Formly Error] There is no validator by the name of \"${name}\"`);\n        }\n        return this.validators[name];\n    }\n    /**\n     * @param {?} name\n     * @param {?} message\n     * @return {?}\n     */\n    addValidatorMessage(name, message) {\n        this.messages[name] = message;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    getValidatorMessage(name) {\n        return this.messages[name];\n    }\n    /**\n     * @param {?} manipulator\n     * @return {?}\n     */\n    setManipulator(manipulator) {\n        new manipulator.class()[manipulator.method](this);\n    }\n    /**\n     * @private\n     * @param {?} name\n     * @return {?}\n     */\n    mergeExtendedType(name) {\n        if (!this.types[name].extends) {\n            return;\n        }\n        /** @type {?} */\n        const extendedType = this.getType(this.types[name].extends);\n        if (!this.types[name].component) {\n            this.types[name].component = extendedType.component;\n        }\n        if (!this.types[name].wrappers) {\n            this.types[name].wrappers = extendedType.wrappers;\n        }\n    }\n}\nFormlyConfig.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] }\n];\n/** @nocollapse */ FormlyConfig.ngInjectableDef = defineInjectable({ factory: function FormlyConfig_Factory() { return new FormlyConfig(); }, token: FormlyConfig, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass FormlyFormBuilder {\n    /**\n     * @param {?} formlyConfig\n     * @param {?} componentFactoryResolver\n     * @param {?} injector\n     */\n    constructor(formlyConfig, componentFactoryResolver, injector) {\n        this.formlyConfig = formlyConfig;\n        this.componentFactoryResolver = componentFactoryResolver;\n        this.injector = injector;\n    }\n    /**\n     * @param {?} formControl\n     * @param {?=} fieldGroup\n     * @param {?=} model\n     * @param {?=} options\n     * @return {?}\n     */\n    buildForm(formControl, fieldGroup = [], model, options) {\n        if (!this.formlyConfig.extensions.core) {\n            throw new Error('NgxFormly: missing `forRoot()` call. use `forRoot()` when registering the `FormlyModule`.');\n        }\n        /** @type {?} */\n        const field = { fieldGroup, model, formControl, options: this._setOptions(options) };\n        reduceFormUpdateValidityCalls(formControl, (/**\n         * @return {?}\n         */\n        () => this._buildForm(field)));\n        field.options._checkField(field, true);\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n    _buildForm(field) {\n        this.getExtensions().forEach((/**\n         * @param {?} extension\n         * @return {?}\n         */\n        extension => extension.prePopulate && extension.prePopulate(field)));\n        this.getExtensions().forEach((/**\n         * @param {?} extension\n         * @return {?}\n         */\n        extension => extension.onPopulate && extension.onPopulate(field)));\n        if (field.fieldGroup) {\n            field.fieldGroup.forEach((/**\n             * @param {?} f\n             * @return {?}\n             */\n            (f) => this._buildForm(f)));\n        }\n        this.getExtensions().forEach((/**\n         * @param {?} extension\n         * @return {?}\n         */\n        extension => extension.postPopulate && extension.postPopulate(field)));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    getExtensions() {\n        return Object.keys(this.formlyConfig.extensions).map((/**\n         * @param {?} name\n         * @return {?}\n         */\n        name => this.formlyConfig.extensions[name]));\n    }\n    /**\n     * @private\n     * @param {?} options\n     * @return {?}\n     */\n    _setOptions(options) {\n        options = options || {};\n        options.formState = options.formState || {};\n        if (!options.showError) {\n            options.showError = this.formlyConfig.extras.showError;\n        }\n        if (!options.fieldChanges) {\n            defineHiddenProp(options, 'fieldChanges', new Subject());\n        }\n        if (!options._resolver) {\n            defineHiddenProp(options, '_resolver', this.componentFactoryResolver);\n        }\n        if (!options._injector) {\n            defineHiddenProp(options, '_injector', this.injector);\n        }\n        if (!options._hiddenFieldsForCheck) {\n            options._hiddenFieldsForCheck = [];\n        }\n        if (!options._markForCheck) {\n            options._markForCheck = (/**\n             * @param {?} field\n             * @return {?}\n             */\n            (field) => {\n                if (field._componentRefs) {\n                    field._componentRefs.forEach((/**\n                     * @param {?} ref\n                     * @return {?}\n                     */\n                    ref => ref.changeDetectorRef.markForCheck()));\n                }\n                if (field.fieldGroup) {\n                    field.fieldGroup.forEach((/**\n                     * @param {?} f\n                     * @return {?}\n                     */\n                    f => options._markForCheck(f)));\n                }\n            });\n        }\n        return options;\n    }\n}\nFormlyFormBuilder.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] }\n];\n/** @nocollapse */\nFormlyFormBuilder.ctorParameters = () => [\n    { type: FormlyConfig },\n    { type: ComponentFactoryResolver },\n    { type: Injector }\n];\n/** @nocollapse */ FormlyFormBuilder.ngInjectableDef = defineInjectable({ factory: function FormlyFormBuilder_Factory() { return new FormlyFormBuilder(inject(FormlyConfig), inject(ComponentFactoryResolver), inject(INJECTOR)); }, token: FormlyFormBuilder, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass FormlyForm {\n    /**\n     * @param {?} formlyBuilder\n     * @param {?} formlyConfig\n     * @param {?} ngZone\n     * @param {?} immutable\n     * @param {?} parentFormGroup\n     */\n    constructor(formlyBuilder, formlyConfig, ngZone, \n    // tslint:disable-next-line\n    immutable, parentFormGroup) {\n        this.formlyBuilder = formlyBuilder;\n        this.formlyConfig = formlyConfig;\n        this.ngZone = ngZone;\n        this.parentFormGroup = parentFormGroup;\n        this.modelChange = new EventEmitter();\n        this.immutable = false;\n        this._modelChangeValue = {};\n        this.modelChangeSubs = [];\n        this.modelChange$ = new Subject();\n        this.modelChangeSub = this.modelChange$.pipe(switchMap((/**\n         * @return {?}\n         */\n        () => this.ngZone.onStable.asObservable().pipe(take(1))))).subscribe((/**\n         * @return {?}\n         */\n        () => this.ngZone.runGuarded((/**\n         * @return {?}\n         */\n        () => {\n            // runGuarded is used to keep in sync the expression changes\n            // https://github.com/ngx-formly/ngx-formly/issues/2095\n            this.checkExpressionChange();\n            this.modelChange.emit(this._modelChangeValue = clone(this.model));\n        }))));\n        if (immutable !== null) {\n            console.warn(`NgxFormly: passing 'immutable' attribute to 'formly-form' component is deprecated since v5.5, enable immutable mode through NgModule declaration instead.`);\n        }\n        this.immutable = (immutable !== null) || !!formlyConfig.extras.immutable;\n    }\n    /**\n     * @param {?} model\n     * @return {?}\n     */\n    set model(model) { this._model = this.immutable ? clone(model) : model; }\n    /**\n     * @return {?}\n     */\n    get model() { return this._model || {}; }\n    /**\n     * @param {?} fields\n     * @return {?}\n     */\n    set fields(fields) { this._fields = this.immutable ? clone(fields) : fields; }\n    /**\n     * @return {?}\n     */\n    get fields() { return this._fields || []; }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    set options(options) { this._options = this.immutable ? clone(options) : options; }\n    /**\n     * @return {?}\n     */\n    get options() { return this._options; }\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    set content(content) {\n        if (content && content.nativeElement.nextSibling) {\n            console.warn(`NgxFormly: content projection for 'formly-form' component is deprecated since v5.5, you should avoid passing content inside the 'formly-form' tag.`);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngDoCheck() {\n        if (this.formlyConfig.extras.checkExpressionOn === 'changeDetectionCheck') {\n            this.checkExpressionChange();\n        }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes.fields || changes.form || (changes.model && this._modelChangeValue !== changes.model.currentValue)) {\n            this.form = this.form || (new FormGroup({}));\n            this.setOptions();\n            this.options.updateInitialValue();\n            this.clearModelSubscriptions();\n            this.formlyBuilder.buildForm(this.form, this.fields, this.model, this.options);\n            this.trackModelChanges(this.fields);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.modelChangeSub.unsubscribe();\n        this.clearModelSubscriptions();\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    changeModel({ key, value, field }) {\n        if (value == null\n            && field['autoClear']\n            && !field.formControl.parent) {\n            /** @type {?} */\n            const paths = key.split('.');\n            /** @type {?} */\n            const k = paths.pop();\n            /** @type {?} */\n            const m = paths.reduce((/**\n             * @param {?} model\n             * @param {?} path\n             * @return {?}\n             */\n            (model, path) => model[path] || {}), this.model);\n            delete m[k];\n        }\n        else {\n            assignModelValue(this.model, key.split('.'), value);\n        }\n        this.modelChange$.next();\n    }\n    /**\n     * @return {?}\n     */\n    setOptions() {\n        if (!this.options) {\n            this.options = {};\n        }\n        if (!this.options.resetModel) {\n            this.options.resetModel = (/**\n             * @param {?=} model\n             * @return {?}\n             */\n            (model) => {\n                model = clone(isNullOrUndefined(model) ? ((/** @type {?} */ (this.options)))._initialModel : model);\n                if (this.model) {\n                    Object.keys(this.model).forEach((/**\n                     * @param {?} k\n                     * @return {?}\n                     */\n                    k => delete this.model[k]));\n                    Object.assign(this.model, model || {});\n                }\n                ((/** @type {?} */ (this.options)))._buildForm();\n                // we should call `NgForm::resetForm` to ensure changing `submitted` state after resetting form\n                // but only when the current component is a root one.\n                if (this.options.parentForm && this.options.parentForm.control === this.form) {\n                    this.options.parentForm.resetForm(model);\n                }\n                else {\n                    this.form.reset(model);\n                }\n            });\n        }\n        if (!this.options.parentForm && this.parentFormGroup) {\n            defineHiddenProp(this.options, 'parentForm', this.parentFormGroup);\n            wrapProperty(this.options.parentForm, 'submitted', (/**\n             * @param {?} __0\n             * @return {?}\n             */\n            ({ firstChange }) => {\n                if (!firstChange) {\n                    this.checkExpressionChange();\n                    ((/** @type {?} */ (this.options)))._markForCheck({\n                        fieldGroup: this.fields,\n                        model: this.model,\n                        formControl: this.form,\n                        options: this.options,\n                    });\n                }\n            }));\n        }\n        if (!this.options.updateInitialValue) {\n            this.options.updateInitialValue = (/**\n             * @return {?}\n             */\n            () => ((/** @type {?} */ (this.options)))._initialModel = clone(this.model));\n        }\n        if (!((/** @type {?} */ (this.options)))._buildForm) {\n            ((/** @type {?} */ (this.options)))._buildForm = (/**\n             * @param {?=} emitModelChange\n             * @return {?}\n             */\n            (emitModelChange = false) => {\n                this.clearModelSubscriptions();\n                this.formlyBuilder.buildForm(this.form, this.fields, this.model, this.options);\n                this.trackModelChanges(this.fields);\n                if (emitModelChange) {\n                    this.modelChange.emit(this._modelChangeValue = clone(this.model));\n                }\n            });\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    checkExpressionChange() {\n        if (this.options && ((/** @type {?} */ (this.options)))._checkField) {\n            ((/** @type {?} */ (this.options)))._checkField({\n                fieldGroup: this.fields,\n                model: this.model,\n                formControl: this.form,\n                options: this.options,\n            });\n        }\n    }\n    /**\n     * @private\n     * @param {?} fields\n     * @param {?=} rootKey\n     * @return {?}\n     */\n    trackModelChanges(fields, rootKey = []) {\n        fields.forEach((/**\n         * @param {?} field\n         * @return {?}\n         */\n        field => {\n            if (field.key && !field.fieldGroup) {\n                /** @type {?} */\n                const control = field.formControl;\n                /** @type {?} */\n                let valueChanges = control.valueChanges.pipe(distinctUntilChanged());\n                const { updateOn, debounce } = field.modelOptions;\n                if ((!updateOn || updateOn === 'change') && debounce && debounce.default > 0) {\n                    valueChanges = control.valueChanges.pipe(debounceTime(debounce.default));\n                }\n                this.modelChangeSubs.push(valueChanges.subscribe((/**\n                 * @param {?} value\n                 * @return {?}\n                 */\n                (value) => {\n                    // workaround for https://github.com/angular/angular/issues/13792\n                    if (control instanceof FormControl && control['_fields'] && control['_fields'].length > 1) {\n                        control.patchValue(value, { emitEvent: false, onlySelf: true });\n                    }\n                    if (field.parsers && field.parsers.length > 0) {\n                        field.parsers.forEach((/**\n                         * @param {?} parserFn\n                         * @return {?}\n                         */\n                        parserFn => value = parserFn(value)));\n                    }\n                    this.changeModel({ key: [...rootKey, ...getKeyPath(field)].join('.'), value, field });\n                })));\n                // workaround for v5 (https://github.com/ngx-formly/ngx-formly/issues/2061)\n                /** @type {?} */\n                const observers = control.valueChanges['observers'];\n                if (observers && observers.length > 1) {\n                    observers.unshift(observers.pop());\n                }\n            }\n            if (field.fieldGroup && field.fieldGroup.length > 0) {\n                this.trackModelChanges(field.fieldGroup, field.key ? [...rootKey, ...getKeyPath(field)] : rootKey);\n            }\n        }));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    clearModelSubscriptions() {\n        this.modelChangeSubs.forEach((/**\n         * @param {?} sub\n         * @return {?}\n         */\n        sub => sub.unsubscribe()));\n        this.modelChangeSubs = [];\n    }\n}\nFormlyForm.decorators = [\n    { type: Component, args: [{\n                selector: 'formly-form',\n                template: `\n    <formly-field *ngFor=\"let field of fields\"\n      hide-deprecation\n      [form]=\"field.form\"\n      [options]=\"field.options\"\n      [model]=\"field.model\"\n      [field]=\"field\">\n    </formly-field>\n    <ng-container #content>\n      <ng-content></ng-content>\n    </ng-container>\n  `,\n                providers: [FormlyFormBuilder]\n            }] }\n];\n/** @nocollapse */\nFormlyForm.ctorParameters = () => [\n    { type: FormlyFormBuilder },\n    { type: FormlyConfig },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Attribute, args: ['immutable',] }] },\n    { type: FormGroupDirective, decorators: [{ type: Optional }] }\n];\nFormlyForm.propDecorators = {\n    form: [{ type: Input }],\n    model: [{ type: Input }],\n    fields: [{ type: Input }],\n    options: [{ type: Input }],\n    modelChange: [{ type: Output }],\n    content: [{ type: ViewChild, args: ['content',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass FormlyField {\n    /**\n     * @param {?} formlyConfig\n     * @param {?} renderer\n     * @param {?} resolver\n     * @param {?} elementRef\n     * @param {?} hideDeprecation\n     */\n    constructor(formlyConfig, renderer, resolver, elementRef, \n    // tslint:disable-next-line\n    hideDeprecation) {\n        this.formlyConfig = formlyConfig;\n        this.renderer = renderer;\n        this.resolver = resolver;\n        this.elementRef = elementRef;\n        this.warnDeprecation = false;\n        this.modelChange = new EventEmitter();\n        this.hostObservers = [];\n        this.componentRefs = [];\n        this.warnDeprecation = hideDeprecation === null;\n    }\n    /**\n     * @param {?} m\n     * @return {?}\n     */\n    set model(m) {\n        this.warnDeprecation && console.warn(`NgxFormly: passing 'model' input to '${this.constructor.name}' component is not required anymore, you may remove it!`);\n    }\n    /**\n     * @param {?} form\n     * @return {?}\n     */\n    set form(form) {\n        this.warnDeprecation && console.warn(`NgxFormly: passing 'form' input to '${this.constructor.name}' component is not required anymore, you may remove it!`);\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    set options(options) {\n        this.warnDeprecation && console.warn(`NgxFormly: passing 'options' input to '${this.constructor.name}' component is not required anymore, you may remove it!`);\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this.triggerHook('afterContentInit');\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentChecked() {\n        this.triggerHook('afterContentChecked');\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        this.triggerHook('afterViewInit');\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewChecked() {\n        this.triggerHook('afterViewChecked');\n    }\n    /**\n     * @return {?}\n     */\n    ngDoCheck() {\n        this.triggerHook('doCheck');\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this.triggerHook('onInit');\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        this.triggerHook('onChanges', changes);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.field && this.resetRefs(this.field);\n        this.hostObservers.forEach((/**\n         * @param {?} unsubscribe\n         * @return {?}\n         */\n        unsubscribe => unsubscribe()));\n        this.triggerHook('onDestroy');\n    }\n    /**\n     * @private\n     * @param {?} containerRef\n     * @param {?} f\n     * @param {?} wrappers\n     * @return {?}\n     */\n    renderField(containerRef, f, wrappers) {\n        if (this.containerRef === containerRef) {\n            this.resetRefs(this.field);\n            this.containerRef.clear();\n        }\n        if (wrappers && wrappers.length > 0) {\n            const [wrapper, ...wps] = wrappers;\n            const { component } = this.formlyConfig.getWrapper(wrapper);\n            /** @type {?} */\n            const ref = containerRef.createComponent(this.resolver.resolveComponentFactory(component));\n            this.attachComponentRef(ref, f);\n            wrapProperty(ref.instance, 'fieldComponent', (/**\n             * @param {?} __0\n             * @return {?}\n             */\n            ({ firstChange, previousValue, currentValue }) => {\n                if (currentValue) {\n                    /** @type {?} */\n                    const viewRef = previousValue ? previousValue.detach() : null;\n                    if (viewRef && !viewRef.destroyed) {\n                        currentValue.insert(viewRef);\n                    }\n                    else {\n                        this.renderField(currentValue, f, wps);\n                    }\n                    !firstChange && ref.changeDetectorRef.detectChanges();\n                }\n            }));\n        }\n        else if (f.type) {\n            const { component } = this.formlyConfig.getType(f.type);\n            /** @type {?} */\n            const ref = containerRef.createComponent(this.resolver.resolveComponentFactory(component));\n            this.attachComponentRef(ref, f);\n        }\n    }\n    /**\n     * @private\n     * @param {?} name\n     * @param {?=} changes\n     * @return {?}\n     */\n    triggerHook(name, changes) {\n        if (this.field.hooks && this.field.hooks[name]) {\n            if (!changes || changes.field) {\n                this.field.hooks[name](this.field);\n            }\n        }\n        if (this.field.lifecycle && this.field.lifecycle[name]) {\n            this.field.lifecycle[name](this.field.form, this.field, this.field.model, this.field.options);\n        }\n        if (name === 'onChanges' && changes.field) {\n            this.renderHostBinding();\n            changes.field.previousValue && this.resetRefs(changes.field.previousValue);\n            this.renderField(this.containerRef, this.field, this.field.wrappers);\n        }\n    }\n    /**\n     * @private\n     * @template T\n     * @param {?} ref\n     * @param {?} field\n     * @return {?}\n     */\n    attachComponentRef(ref, field) {\n        this.componentRefs.push(ref);\n        field._componentRefs.push(ref);\n        Object.assign(ref.instance, { field });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    renderHostBinding() {\n        this.hostObservers.forEach((/**\n         * @param {?} unsubscribe\n         * @return {?}\n         */\n        unsubscribe => unsubscribe()));\n        this.hostObservers = [\n            wrapProperty(this.field, 'hide', (/**\n             * @param {?} __0\n             * @return {?}\n             */\n            ({ firstChange, currentValue }) => {\n                if (!firstChange || (firstChange && currentValue)) {\n                    this.renderer.setStyle(this.elementRef.nativeElement, 'display', currentValue ? 'none' : '');\n                }\n            })),\n            wrapProperty(this.field, 'className', (/**\n             * @param {?} __0\n             * @return {?}\n             */\n            ({ firstChange, currentValue }) => {\n                if (!firstChange || (firstChange && currentValue)) {\n                    this.renderer.setAttribute(this.elementRef.nativeElement, 'class', currentValue);\n                }\n            })),\n        ];\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n    resetRefs(field) {\n        if (field) {\n            if (field._componentRefs) {\n                field._componentRefs = field._componentRefs.filter((/**\n                 * @param {?} ref\n                 * @return {?}\n                 */\n                ref => this.componentRefs.indexOf(ref) === -1));\n            }\n            else {\n                defineHiddenProp(this.field, '_componentRefs', []);\n            }\n        }\n        this.componentRefs = [];\n    }\n}\nFormlyField.decorators = [\n    { type: Component, args: [{\n                selector: 'formly-field',\n                template: `<ng-template #container></ng-template>`\n            }] }\n];\n/** @nocollapse */\nFormlyField.ctorParameters = () => [\n    { type: FormlyConfig },\n    { type: Renderer2 },\n    { type: ComponentFactoryResolver },\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Attribute, args: ['hide-deprecation',] }] }\n];\nFormlyField.propDecorators = {\n    field: [{ type: Input }],\n    model: [{ type: Input }],\n    form: [{ type: Input }],\n    options: [{ type: Input }],\n    modelChange: [{ type: Output }],\n    containerRef: [{ type: ViewChild, args: ['container', (/** @type {?} */ ({ read: ViewContainerRef, static: true })),] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass FormlyAttributes {\n    /**\n     * @param {?} renderer\n     * @param {?} elementRef\n     * @param {?} _document\n     */\n    constructor(renderer, elementRef, _document) {\n        this.renderer = renderer;\n        this.elementRef = elementRef;\n        this.uiAttributesCache = {};\n        this.uiAttributes = [\n            ...FORMLY_VALIDATORS,\n            'tabindex',\n            'placeholder',\n            'readonly',\n            'disabled',\n            'step',\n        ];\n        /**\n         * HostBinding doesn't register listeners conditionally which may produce some perf issues.\n         *\n         * Formly issue: https://github.com/ngx-formly/ngx-formly/issues/1991\n         */\n        this.uiEvents = {\n            listeners: [],\n            events: [\n                'click',\n                'keyup',\n                'keydown',\n                'keypress',\n            ],\n        };\n        this.document = _document;\n    }\n    /**\n     * @return {?}\n     */\n    get to() { return this.field.templateOptions || {}; }\n    /**\n     * @private\n     * @return {?}\n     */\n    get fieldAttrElements() { return (this.field && this.field['_elementRefs']) || []; }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes.field) {\n            this.field.name && this.setAttribute('name', this.field.name);\n            this.uiEvents.listeners.forEach((/**\n             * @param {?} listener\n             * @return {?}\n             */\n            listener => listener()));\n            this.uiEvents.events.forEach((/**\n             * @param {?} eventName\n             * @return {?}\n             */\n            eventName => {\n                if (this.to && this.to[eventName]) {\n                    this.uiEvents.listeners.push(this.renderer.listen(this.elementRef.nativeElement, eventName, (/**\n                     * @param {?} e\n                     * @return {?}\n                     */\n                    (e) => this.to[eventName](this.field, e))));\n                }\n            }));\n            if (this.to && this.to.attributes) {\n                wrapProperty(this.to, 'attributes', (/**\n                 * @param {?} __0\n                 * @return {?}\n                 */\n                ({ currentValue, previousValue }) => {\n                    if (previousValue) {\n                        Object.keys(previousValue).forEach((/**\n                         * @param {?} attr\n                         * @return {?}\n                         */\n                        attr => this.removeAttribute(attr)));\n                    }\n                    if (currentValue) {\n                        Object.keys(currentValue).forEach((/**\n                         * @param {?} attr\n                         * @return {?}\n                         */\n                        attr => this.setAttribute(attr, currentValue[attr])));\n                    }\n                }));\n            }\n            this.detachElementRef(changes.field.previousValue);\n            this.attachElementRef(changes.field.currentValue);\n            if (this.fieldAttrElements.length === 1) {\n                !this.id && this.field.id && this.setAttribute('id', this.field.id);\n                wrapProperty(this.field, 'focus', (/**\n                 * @param {?} __0\n                 * @return {?}\n                 */\n                ({ currentValue }) => {\n                    this.toggleFocus(currentValue);\n                }));\n            }\n        }\n        if (changes.id) {\n            this.setAttribute('id', this.id);\n        }\n    }\n    /**\n     * We need to re-evaluate all the attributes on every change detection cycle, because\n     * by using a HostBinding we run into certain edge cases. This means that whatever logic\n     * is in here has to be super lean or we risk seriously damaging or destroying the performance.\n     *\n     * Formly issue: https://github.com/ngx-formly/ngx-formly/issues/1317\n     * Material issue: https://github.com/angular/components/issues/14024\n     * @return {?}\n     */\n    ngDoCheck() {\n        this.uiAttributes.forEach((/**\n         * @param {?} attr\n         * @return {?}\n         */\n        attr => {\n            /** @type {?} */\n            const value = this.to[attr];\n            if (this.uiAttributesCache[attr] !== value) {\n                this.uiAttributesCache[attr] = value;\n                if (value || value === 0) {\n                    this.setAttribute(attr, value === true ? attr : `${value}`);\n                }\n                else {\n                    this.removeAttribute(attr);\n                }\n            }\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.uiEvents.listeners.forEach((/**\n         * @param {?} listener\n         * @return {?}\n         */\n        listener => listener()));\n        this.detachElementRef(this.field);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    toggleFocus(value) {\n        /** @type {?} */\n        const element = this.fieldAttrElements ? this.fieldAttrElements[0] : null;\n        if (!element || !element.nativeElement.focus) {\n            return;\n        }\n        /** @type {?} */\n        const isFocused = !!this.document.activeElement\n            && this.fieldAttrElements\n                .some((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            ({ nativeElement }) => this.document.activeElement === nativeElement || nativeElement.contains(this.document.activeElement)));\n        if (value && !isFocused) {\n            element.nativeElement.focus();\n        }\n        else if (!value && isFocused) {\n            element.nativeElement.blur();\n        }\n    }\n    /**\n     * @param {?} $event\n     * @return {?}\n     */\n    onFocus($event) {\n        this.field['___$focus'] = true;\n        if (this.to.focus) {\n            this.to.focus(this.field, $event);\n        }\n    }\n    /**\n     * @param {?} $event\n     * @return {?}\n     */\n    onBlur($event) {\n        this.field['___$focus'] = false;\n        if (this.to.blur) {\n            this.to.blur(this.field, $event);\n        }\n    }\n    /**\n     * @param {?} $event\n     * @return {?}\n     */\n    onChange($event) {\n        if (this.to.change) {\n            this.to.change(this.field, $event);\n        }\n        if (this.field.formControl) {\n            this.field.formControl.markAsDirty();\n        }\n    }\n    /**\n     * @private\n     * @param {?} f\n     * @return {?}\n     */\n    attachElementRef(f) {\n        if (!f) {\n            return;\n        }\n        if (f['_elementRefs'] && f['_elementRefs'].indexOf(this.elementRef) === -1) {\n            f['_elementRefs'].push(this.elementRef);\n        }\n        else {\n            defineHiddenProp(f, '_elementRefs', [this.elementRef]);\n        }\n    }\n    /**\n     * @private\n     * @param {?} f\n     * @return {?}\n     */\n    detachElementRef(f) {\n        /** @type {?} */\n        const index = f && f['_elementRefs'] ? this.fieldAttrElements.indexOf(this.elementRef) : -1;\n        if (index !== -1) {\n            this.field['_elementRefs'].splice(index, 1);\n        }\n    }\n    /**\n     * @private\n     * @param {?} attr\n     * @param {?} value\n     * @return {?}\n     */\n    setAttribute(attr, value) {\n        this.renderer.setAttribute(this.elementRef.nativeElement, attr, value);\n    }\n    /**\n     * @private\n     * @param {?} attr\n     * @return {?}\n     */\n    removeAttribute(attr) {\n        this.renderer.removeAttribute(this.elementRef.nativeElement, attr);\n    }\n}\nFormlyAttributes.decorators = [\n    { type: Directive, args: [{\n                selector: '[formlyAttributes]',\n                host: {\n                    '(focus)': 'onFocus($event)',\n                    '(blur)': 'onBlur($event)',\n                    '(change)': 'onChange($event)',\n                },\n            },] }\n];\n/** @nocollapse */\nFormlyAttributes.ctorParameters = () => [\n    { type: Renderer2 },\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\nFormlyAttributes.propDecorators = {\n    field: [{ type: Input, args: ['formlyAttributes',] }],\n    id: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @abstract\n * @template F\n */\nclass FieldType {\n    /**\n     * @return {?}\n     */\n    get model() { return this.field.model; }\n    /**\n     * @param {?} m\n     * @return {?}\n     */\n    set model(m) { console.warn(`NgxFormly: passing 'model' input to '${this.constructor.name}' component is not required anymore, you may remove it!`); }\n    /**\n     * @return {?}\n     */\n    get form() { return (/** @type {?} */ (this.field.parent.formControl)); }\n    /**\n     * @param {?} form\n     * @return {?}\n     */\n    set form(form) { console.warn(`NgxFormly: passing 'form' input to '${this.constructor.name}' component is not required anymore, you may remove it!`); }\n    /**\n     * @return {?}\n     */\n    get options() { return this.field.options; }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    set options(options) { console.warn(`NgxFormly: passing 'options' input to '${this.constructor.name}' component is not required anymore, you may remove it!`); }\n    /**\n     * @return {?}\n     */\n    get key() { return this.field.key; }\n    /**\n     * @return {?}\n     */\n    get formControl() { return this.field.formControl; }\n    /**\n     * @return {?}\n     */\n    get to() { return this.field.templateOptions || {}; }\n    /**\n     * @return {?}\n     */\n    get showError() { return this.options.showError(this); }\n    /**\n     * @return {?}\n     */\n    get id() { return this.field.id; }\n    /**\n     * @return {?}\n     */\n    get formState() { return this.options.formState || {}; }\n}\nFieldType.propDecorators = {\n    field: [{ type: Input }],\n    model: [{ type: Input }],\n    form: [{ type: Input }],\n    options: [{ type: Input }]\n};\n/**\n * @deprecated use `FieldType` instead\n * @abstract\n */\nclass Field extends FieldType {\n    constructor() {\n        super();\n        console.warn(`NgxFormly: 'Field' has been renamed to 'FieldType', extend 'FieldType' instead.`);\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} field\n * @param {?=} emitEvent\n * @return {?}\n */\nfunction unregisterControl(field, emitEvent = false) {\n    /** @type {?} */\n    const form = (/** @type {?} */ (field.formControl.parent));\n    if (!form) {\n        return;\n    }\n    /** @type {?} */\n    const control = field.formControl;\n    /** @type {?} */\n    const opts = { emitEvent };\n    if (form instanceof FormArray) {\n        /** @type {?} */\n        const key = form.controls.findIndex((/**\n         * @param {?} c\n         * @return {?}\n         */\n        c => c === control));\n        if (key !== -1) {\n            updateControl(form, opts, (/**\n             * @return {?}\n             */\n            () => form.removeAt(key)));\n        }\n    }\n    else if (form instanceof FormGroup) {\n        /** @type {?} */\n        const paths = getKeyPath(field);\n        /** @type {?} */\n        const key = paths[paths.length - 1];\n        if (form.get([key]) === control) {\n            updateControl(form, opts, (/**\n             * @return {?}\n             */\n            () => form.removeControl(key)));\n        }\n    }\n    control.setParent(null);\n    if (field['autoClear']) {\n        if (field.parent.model) {\n            delete field.parent.model[field.key];\n        }\n        control.reset({ value: undefined, disabled: control.disabled }, { emitEvent: field.fieldGroup ? false : emitEvent, onlySelf: true });\n    }\n}\n/**\n * @param {?} field\n * @return {?}\n */\nfunction findControl(field) {\n    if (field.formControl) {\n        return field.formControl;\n    }\n    /** @type {?} */\n    const form = (/** @type {?} */ (field.parent.formControl));\n    return form ? form.get(getKeyPath(field)) : null;\n}\n/**\n * @param {?} field\n * @param {?=} control\n * @param {?=} emitEvent\n * @return {?}\n */\nfunction registerControl(field, control, emitEvent = false) {\n    control = control || field.formControl;\n    if (!control['_fields']) {\n        defineHiddenProp(control, '_fields', []);\n    }\n    if (control['_fields'].indexOf(field) === -1) {\n        control['_fields'].push(field);\n    }\n    if (!field.formControl && control) {\n        defineHiddenProp(field, 'formControl', control);\n        field.templateOptions.disabled = !!field.templateOptions.disabled;\n        wrapProperty(field.templateOptions, 'disabled', (/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ({ firstChange, currentValue }) => {\n            if (!firstChange) {\n                currentValue ? field.formControl.disable() : field.formControl.enable();\n            }\n        }));\n        if (control.registerOnDisabledChange) {\n            control.registerOnDisabledChange((/**\n             * @param {?} value\n             * @return {?}\n             */\n            (value) => field.templateOptions['___$disabled'] = value));\n        }\n    }\n    /** @type {?} */\n    let parent = (/** @type {?} */ (field.parent.formControl));\n    if (!parent) {\n        return;\n    }\n    /** @type {?} */\n    const paths = getKeyPath(field);\n    if (!parent['_formlyControls']) {\n        defineHiddenProp(parent, '_formlyControls', {});\n    }\n    parent['_formlyControls'][paths.join('.')] = control;\n    for (let i = 0; i < (paths.length - 1); i++) {\n        /** @type {?} */\n        const path = paths[i];\n        if (!parent.get([path])) {\n            registerControl({\n                key: path,\n                formControl: new FormGroup({}),\n                parent: { formControl: parent },\n            });\n        }\n        parent = (/** @type {?} */ (parent.get([path])));\n    }\n    if (field['autoClear'] && !isUndefined(field.defaultValue) && isUndefined(getFieldValue(field))) {\n        assignModelValue(field.parent.model, getKeyPath(field), field.defaultValue);\n    }\n    /** @type {?} */\n    const value = getFieldValue(field);\n    if (!(isNullOrUndefined(control.value) && isNullOrUndefined(value))\n        && control.value !== value\n        && control instanceof FormControl) {\n        control.patchValue(value);\n    }\n    /** @type {?} */\n    const key = paths[paths.length - 1];\n    if (!field._hide && parent.get([key]) !== control) {\n        updateControl(parent, { emitEvent }, (/**\n         * @return {?}\n         */\n        () => parent.setControl(key, control)));\n    }\n}\n/**\n * @param {?} form\n * @param {?} opts\n * @param {?} action\n * @return {?}\n */\nfunction updateControl(form, opts, action) {\n    /**\n     *  workaround for https://github.com/angular/angular/issues/27679\n     */\n    if (form instanceof FormGroup && !form['__patchForEachChild']) {\n        defineHiddenProp(form, '__patchForEachChild', true);\n        ((/** @type {?} */ (form)))._forEachChild = (/**\n         * @param {?} cb\n         * @return {?}\n         */\n        (cb) => {\n            Object\n                .keys(form.controls)\n                .forEach((/**\n             * @param {?} k\n             * @return {?}\n             */\n            k => form.controls[k] && cb(form.controls[k], k)));\n        });\n    }\n    /**\n     * workaround for https://github.com/angular/angular/issues/20439\n     * @type {?}\n     */\n    const updateValueAndValidity = form.updateValueAndValidity.bind(form);\n    if (opts.emitEvent === false) {\n        form.updateValueAndValidity = (/**\n         * @param {?} opts\n         * @return {?}\n         */\n        (opts) => {\n            updateValueAndValidity(Object.assign({}, (opts || {}), { emitEvent: false }));\n        });\n    }\n    action();\n    if (opts.emitEvent === false) {\n        form.updateValueAndValidity = updateValueAndValidity;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @abstract\n * @template F\n */\nclass FieldArrayType extends FieldType {\n    /**\n     * @param {?=} builder\n     */\n    constructor(builder) {\n        super();\n        this.defaultOptions = {\n            defaultValue: [],\n        };\n        if (builder instanceof FormlyFormBuilder) {\n            console.warn(`NgxFormly: passing 'FormlyFormBuilder' to '${this.constructor.name}' type is not required anymore, you may remove it!`);\n        }\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n    onPopulate(field) {\n        if (!field.formControl) {\n            registerControl(field, new FormArray([], { updateOn: field.modelOptions.updateOn }));\n        }\n        field.fieldGroup = field.fieldGroup || [];\n        /** @type {?} */\n        const length = field.model ? field.model.length : 0;\n        if (field.fieldGroup.length > length) {\n            for (let i = field.fieldGroup.length - 1; i >= length; --i) {\n                unregisterControl(field.fieldGroup[i]);\n                field.fieldGroup.splice(i, 1);\n            }\n        }\n        for (let i = field.fieldGroup.length; i < length; i++) {\n            /** @type {?} */\n            const f = Object.assign({}, clone(field.fieldArray), { key: `${i}` });\n            field.fieldGroup.push(f);\n        }\n    }\n    /**\n     * @param {?=} i\n     * @param {?=} initialModel\n     * @return {?}\n     */\n    add(i, initialModel) {\n        i = isNullOrUndefined(i) ? this.field.fieldGroup.length : i;\n        if (!this.model) {\n            assignModelValue(this.field.parent.model, getKeyPath(this.field), []);\n        }\n        this.model.splice(i, 0, initialModel ? clone(initialModel) : undefined);\n        ((/** @type {?} */ (this.options)))._buildForm(true);\n        this.formControl.markAsDirty();\n    }\n    /**\n     * @param {?} i\n     * @return {?}\n     */\n    remove(i) {\n        this.model.splice(i, 1);\n        unregisterControl(this.field.fieldGroup[i], true);\n        this.field.fieldGroup.splice(i, 1);\n        this.field.fieldGroup.forEach((/**\n         * @param {?} f\n         * @param {?} key\n         * @return {?}\n         */\n        (f, key) => f.key = `${key}`));\n        ((/** @type {?} */ (this.options)))._buildForm(true);\n        this.formControl.markAsDirty();\n    }\n}\n/** @nocollapse */\nFieldArrayType.ctorParameters = () => [\n    { type: FormlyFormBuilder, decorators: [{ type: Inject, args: [FORMLY_CONFIG,] }, { type: Optional }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @abstract\n * @template F\n */\nclass FieldWrapper extends FieldType {\n}\nFieldWrapper.propDecorators = {\n    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', (/** @type {?} */ ({ read: ViewContainerRef, static: false })),] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass FormlyGroup extends FieldType {\n    constructor() {\n        super(...arguments);\n        this.defaultOptions = {\n            defaultValue: {},\n        };\n    }\n}\nFormlyGroup.decorators = [\n    { type: Component, args: [{\n                selector: 'formly-group',\n                template: `\n    <formly-field *ngFor=\"let f of field.fieldGroup\" [field]=\"f\"></formly-field>\n    <ng-content></ng-content>\n  `,\n                host: {\n                    '[class]': 'field.fieldGroupClassName || \"\"',\n                }\n            }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass FormlyValidationMessage {\n    /**\n     * @param {?} formlyConfig\n     */\n    constructor(formlyConfig) {\n        this.formlyConfig = formlyConfig;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnChanges() {\n        this.errorMessage$ = this.field.formControl.statusChanges.pipe(startWith(null), map((/**\n         * @return {?}\n         */\n        () => this.errorMessage)));\n    }\n    /**\n     * @return {?}\n     */\n    get errorMessage() {\n        /** @type {?} */\n        const fieldForm = this.field.formControl;\n        for (let error in fieldForm.errors) {\n            if (fieldForm.errors.hasOwnProperty(error)) {\n                /** @type {?} */\n                let message = this.formlyConfig.getValidatorMessage(error);\n                if (isObject(fieldForm.errors[error])) {\n                    if (fieldForm.errors[error].errorPath) {\n                        return;\n                    }\n                    if (fieldForm.errors[error].message) {\n                        message = fieldForm.errors[error].message;\n                    }\n                }\n                if (this.field.validation && this.field.validation.messages && this.field.validation.messages[error]) {\n                    message = this.field.validation.messages[error];\n                }\n                if (this.field.validators && this.field.validators[error] && this.field.validators[error].message) {\n                    message = this.field.validators[error].message;\n                }\n                if (this.field.asyncValidators && this.field.asyncValidators[error] && this.field.asyncValidators[error].message) {\n                    message = this.field.asyncValidators[error].message;\n                }\n                if (typeof message === 'function') {\n                    return message(fieldForm.errors[error], this.field);\n                }\n                return message;\n            }\n        }\n    }\n}\nFormlyValidationMessage.decorators = [\n    { type: Component, args: [{\n                selector: 'formly-validation-message',\n                template: `{{ errorMessage$ | async }}`,\n                changeDetection: ChangeDetectionStrategy.OnPush\n            }] }\n];\n/** @nocollapse */\nFormlyValidationMessage.ctorParameters = () => [\n    { type: FormlyConfig }\n];\nFormlyValidationMessage.propDecorators = {\n    field: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass FormlyTemplateType extends FieldType {\n}\nFormlyTemplateType.decorators = [\n    { type: Component, args: [{\n                selector: 'formly-template',\n                template: `<div [innerHtml]=\"field.template\"></div>`\n            }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} expression\n * @param {?} argNames\n * @return {?}\n */\nfunction evalStringExpression(expression, argNames) {\n    try {\n        if (expression.indexOf('this.field') !== -1) {\n            console.warn(`NgxFormly: using 'this.field' in expressionProperties is deprecated since v5.1, use 'field' instead.`);\n        }\n        return (/** @type {?} */ (Function(...argNames, `return ${expression};`)));\n    }\n    catch (error) {\n        console.error(error);\n    }\n}\n/**\n * @param {?} expression\n * @param {?} argNames\n * @return {?}\n */\nfunction evalExpressionValueSetter(expression, argNames) {\n    try {\n        return (/** @type {?} */ (Function(...argNames, `${expression} = expressionValue;`)));\n    }\n    catch (error) {\n        console.error(error);\n    }\n}\n/**\n * @param {?} expression\n * @param {?} thisArg\n * @param {?} argVal\n * @return {?}\n */\nfunction evalExpression(expression, thisArg, argVal) {\n    if (expression instanceof Function) {\n        return expression.apply(thisArg, argVal);\n    }\n    else {\n        return expression ? true : false;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * \\@experimental\n */\nclass FieldExpressionExtension {\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n    prePopulate(field) {\n        if (field.parent || field.options._checkField) {\n            return;\n        }\n        field.options._checkField = (/**\n         * @param {?} f\n         * @param {?} ignoreCache\n         * @return {?}\n         */\n        (f, ignoreCache) => {\n            reduceFormUpdateValidityCalls(f.formControl, (/**\n             * @return {?}\n             */\n            () => this.checkField(f, ignoreCache)));\n        });\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n    onPopulate(field) {\n        if (!field.parent || field._expressionProperties) {\n            return;\n        }\n        // cache built expression\n        defineHiddenProp(field, '_expressionProperties', {});\n        if (field.expressionProperties) {\n            for (const key in field.expressionProperties) {\n                /** @type {?} */\n                const expressionProperty = field.expressionProperties[key];\n                /** @type {?} */\n                const expressionValueSetter = evalExpressionValueSetter(`field.${key}`, ['expressionValue', 'model', 'field']);\n                if (typeof expressionProperty === 'string' || isFunction(expressionProperty)) {\n                    field._expressionProperties[key] = {\n                        expression: this._evalExpression(expressionProperty, field.parent.expressionProperties && field.parent.expressionProperties.hasOwnProperty('templateOptions.disabled')\n                            ? (/**\n                             * @return {?}\n                             */\n                            () => field.parent.templateOptions.disabled)\n                            : undefined),\n                        expressionValueSetter,\n                    };\n                    if (key === 'templateOptions.disabled') {\n                        Object.defineProperty(field._expressionProperties[key], 'expressionValue', {\n                            get: (/**\n                             * @return {?}\n                             */\n                            () => field.templateOptions.disabled),\n                            set: (/**\n                             * @return {?}\n                             */\n                            () => { }),\n                            enumerable: true,\n                            configurable: true,\n                        });\n                    }\n                }\n                else if (expressionProperty instanceof Observable) {\n                    /** @type {?} */\n                    const subscription = ((/** @type {?} */ (expressionProperty)))\n                        .subscribe((/**\n                     * @param {?} v\n                     * @return {?}\n                     */\n                    v => {\n                        this.setExprValue(field, key, expressionValueSetter, v);\n                        if (field.options && field.options._markForCheck) {\n                            field.options._markForCheck(field);\n                        }\n                    }));\n                    /** @type {?} */\n                    const onDestroy = field.hooks.onDestroy;\n                    field.hooks.onDestroy = (/**\n                     * @param {?} field\n                     * @return {?}\n                     */\n                    (field) => {\n                        onDestroy && onDestroy(field);\n                        subscription.unsubscribe();\n                    });\n                }\n            }\n        }\n        if (field.hideExpression) {\n            // delete hide value in order to force re-evaluate it in FormlyFormExpression.\n            delete field.hide;\n            /** @type {?} */\n            let parent = field.parent;\n            while (parent && !parent.hideExpression) {\n                parent = parent.parent;\n            }\n            field.hideExpression = this._evalExpression(field.hideExpression, parent && parent.hideExpression ? (/**\n             * @return {?}\n             */\n            () => parent.hide) : undefined);\n        }\n        else {\n            wrapProperty(field, 'hide', (/**\n             * @param {?} __0\n             * @return {?}\n             */\n            ({ currentValue, firstChange }) => {\n                field._hide = currentValue;\n                if (!firstChange || (firstChange && currentValue === true)) {\n                    field.options._hiddenFieldsForCheck.push(field);\n                }\n            }));\n        }\n    }\n    /**\n     * @private\n     * @param {?} expression\n     * @param {?=} parentExpression\n     * @return {?}\n     */\n    _evalExpression(expression, parentExpression) {\n        expression = expression || ((/**\n         * @return {?}\n         */\n        () => false));\n        if (typeof expression === 'string') {\n            expression = evalStringExpression(expression, ['model', 'formState', 'field']);\n        }\n        return parentExpression\n            ? (/**\n             * @param {?} model\n             * @param {?} formState\n             * @param {?} field\n             * @return {?}\n             */\n            (model, formState, field) => parentExpression() || expression(model, formState, field))\n            : expression;\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?=} ignoreCache\n     * @return {?}\n     */\n    checkField(field, ignoreCache = false) {\n        this._checkField(field, ignoreCache);\n        field.options._hiddenFieldsForCheck\n            .sort((/**\n         * @param {?} f\n         * @return {?}\n         */\n        f => f.hide ? -1 : 1))\n            .forEach((/**\n         * @param {?} f\n         * @return {?}\n         */\n        f => this.toggleFormControl(f, f.hide)));\n        field.options._hiddenFieldsForCheck = [];\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?=} ignoreCache\n     * @return {?}\n     */\n    _checkField(field, ignoreCache = false) {\n        /** @type {?} */\n        let markForCheck = false;\n        field.fieldGroup.forEach((/**\n         * @param {?} f\n         * @return {?}\n         */\n        f => {\n            this.checkFieldExpressionChange(f, ignoreCache) && (markForCheck = true);\n            if (this.checkFieldVisibilityChange(f, ignoreCache)) {\n                field.options._hiddenFieldsForCheck.push(f);\n                markForCheck = true;\n            }\n            if (f.fieldGroup && f.fieldGroup.length > 0) {\n                this._checkField(f, ignoreCache);\n            }\n        }));\n        if (markForCheck && field.options && field.options._markForCheck) {\n            field.options._markForCheck(field);\n        }\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} ignoreCache\n     * @return {?}\n     */\n    checkFieldExpressionChange(field, ignoreCache) {\n        if (!field || !field._expressionProperties) {\n            return false;\n        }\n        /** @type {?} */\n        let markForCheck = false;\n        /** @type {?} */\n        const expressionProperties = field._expressionProperties;\n        for (const key in expressionProperties) {\n            /** @type {?} */\n            let expressionValue = evalExpression(expressionProperties[key].expression, { field }, [field.model, field.options.formState, field]);\n            if (key === 'templateOptions.disabled') {\n                expressionValue = !!expressionValue;\n            }\n            if (ignoreCache || (expressionProperties[key].expressionValue !== expressionValue\n                && (!isObject(expressionValue) || JSON.stringify(expressionValue) !== JSON.stringify(expressionProperties[key].expressionValue)))) {\n                markForCheck = true;\n                expressionProperties[key].expressionValue = expressionValue;\n                /** @type {?} */\n                const setter = expressionProperties[key].expressionValueSetter;\n                this.setExprValue(field, key, setter, expressionValue);\n            }\n        }\n        return markForCheck;\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} ignoreCache\n     * @return {?}\n     */\n    checkFieldVisibilityChange(field, ignoreCache) {\n        if (!field || isNullOrUndefined(field.hideExpression)) {\n            return false;\n        }\n        /** @type {?} */\n        const hideExpressionResult = !!evalExpression(field.hideExpression, { field }, [field.model, field.options.formState, field]);\n        /** @type {?} */\n        let markForCheck = false;\n        if (hideExpressionResult !== field.hide || ignoreCache) {\n            markForCheck = true;\n            // toggle hide\n            field.hide = hideExpressionResult;\n            field.templateOptions.hidden = hideExpressionResult;\n        }\n        return markForCheck;\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} value\n     * @return {?}\n     */\n    setDisabledState(field, value) {\n        if (field.fieldGroup) {\n            field.fieldGroup\n                .filter((/**\n             * @param {?} f\n             * @return {?}\n             */\n            f => !f.expressionProperties || !f.expressionProperties.hasOwnProperty('templateOptions.disabled')))\n                .forEach((/**\n             * @param {?} f\n             * @return {?}\n             */\n            f => this.setDisabledState(f, value)));\n        }\n        if (field.key && field.templateOptions.disabled !== value) {\n            field.templateOptions.disabled = value;\n        }\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} hide\n     * @return {?}\n     */\n    toggleFormControl(field, hide) {\n        if (field.formControl && field.key) {\n            defineHiddenProp(field, '_hide', !!(hide || field.hide));\n            /** @type {?} */\n            const c = field.formControl;\n            if (c['_fields'].length > 1) {\n                c.updateValueAndValidity({ emitEvent: false });\n            }\n            hide === true && c['_fields'].every((/**\n             * @param {?} f\n             * @return {?}\n             */\n            f => !!f._hide))\n                ? unregisterControl(field)\n                : registerControl(field);\n        }\n        if (field.fieldGroup) {\n            field.fieldGroup\n                .filter((/**\n             * @param {?} f\n             * @return {?}\n             */\n            f => !f.hideExpression))\n                .forEach((/**\n             * @param {?} f\n             * @return {?}\n             */\n            f => this.toggleFormControl(f, hide)));\n        }\n        if (field.options.fieldChanges) {\n            field.options.fieldChanges.next((/** @type {?} */ ({ field: field, type: 'hidden', value: hide })));\n        }\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} prop\n     * @param {?} setter\n     * @param {?} value\n     * @return {?}\n     */\n    setExprValue(field, prop, setter, value) {\n        evalExpression(setter, { field }, [value, field.model, field]);\n        if (prop === 'templateOptions.disabled' && field.key) {\n            this.setDisabledState(field, value);\n        }\n        if (prop.indexOf('model.') === 0) {\n            /** @type {?} */\n            const path = prop.replace(/^model\\./, '');\n            /** @type {?} */\n            const control = field.key && prop === path ? field.formControl : field.parent.formControl.get(path);\n            if (control\n                && !(isNullOrUndefined(control.value) && isNullOrUndefined(value))\n                && control.value !== value) {\n                control.patchValue(value, { emitEvent: false });\n            }\n        }\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * \\@experimental\n */\nclass FieldValidationExtension {\n    /**\n     * @param {?} formlyConfig\n     */\n    constructor(formlyConfig) {\n        this.formlyConfig = formlyConfig;\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n    onPopulate(field) {\n        if (!field.parent || !field.key) {\n            return;\n        }\n        this.initFieldValidation(field, 'validators');\n        this.initFieldValidation(field, 'asyncValidators');\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} type\n     * @return {?}\n     */\n    initFieldValidation(field, type) {\n        /** @type {?} */\n        const validators = type === 'validators' ? [this.getPredefinedFieldValidation(field)] : [];\n        if (field[type]) {\n            for (const validatorName in field[type]) {\n                if (validatorName === 'validation' && !Array.isArray(field[type].validation)) {\n                    field[type].validation = [field[type].validation];\n                    console.warn(`NgxFormly(${field.key}): passing a non array value to the 'validation' is deprecated, pass an array instead`);\n                }\n                validatorName === 'validation'\n                    ? validators.push(...field[type].validation.map((/**\n                     * @param {?} v\n                     * @return {?}\n                     */\n                    v => this.wrapNgValidatorFn(field, v))))\n                    : validators.push(this.wrapNgValidatorFn(field, field[type][validatorName], validatorName));\n            }\n        }\n        defineHiddenProp(field, '_' + type, type === 'validators' ? Validators.compose(validators) : Validators.composeAsync((/** @type {?} */ (validators))));\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n    getPredefinedFieldValidation(field) {\n        /** @type {?} */\n        let VALIDATORS = [];\n        FORMLY_VALIDATORS.forEach((/**\n         * @param {?} opt\n         * @return {?}\n         */\n        opt => wrapProperty(field.templateOptions, opt, (/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ({ currentValue, firstChange }) => {\n            VALIDATORS = VALIDATORS.filter((/**\n             * @param {?} o\n             * @return {?}\n             */\n            o => o !== opt));\n            if (currentValue != null && currentValue !== false) {\n                VALIDATORS.push(opt);\n            }\n            if (!firstChange && field.formControl) {\n                field.formControl.updateValueAndValidity({ emitEvent: false });\n            }\n        }))));\n        return (/**\n         * @param {?} control\n         * @return {?}\n         */\n        (control) => {\n            if (VALIDATORS.length === 0) {\n                return null;\n            }\n            return Validators.compose(VALIDATORS.map((/**\n             * @param {?} opt\n             * @return {?}\n             */\n            opt => (/**\n             * @return {?}\n             */\n            () => {\n                /** @type {?} */\n                const value = field.templateOptions[opt];\n                switch (opt) {\n                    case 'required':\n                        return Validators.required(control);\n                    case 'pattern':\n                        return Validators.pattern(value)(control);\n                    case 'minLength':\n                        return Validators.minLength(value)(control);\n                    case 'maxLength':\n                        return Validators.maxLength(value)(control);\n                    case 'min':\n                        return Validators.min(value)(control);\n                    case 'max':\n                        return Validators.max(value)(control);\n                }\n            }))))(control);\n        });\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} validator\n     * @param {?=} validatorName\n     * @return {?}\n     */\n    wrapNgValidatorFn(field, validator, validatorName) {\n        return (/**\n         * @param {?} control\n         * @return {?}\n         */\n        (control) => {\n            /** @type {?} */\n            let validatorFn = (/** @type {?} */ (validator));\n            if (typeof validator === 'string') {\n                validatorFn = this.formlyConfig.getValidator(validator).validation;\n            }\n            if (isObject(validator)) {\n                validatorFn = ((/** @type {?} */ (validator))).expression;\n            }\n            /** @type {?} */\n            const isValid = validatorFn(control, field);\n            if (validatorName) {\n                if (isPromise(isValid)) {\n                    return isValid.then((/**\n                     * @param {?} result\n                     * @return {?}\n                     */\n                    (result) => {\n                        // workaround for https://github.com/angular/angular/issues/13200\n                        if (field.options && field.options._markForCheck) {\n                            field.options._markForCheck(field);\n                        }\n                        return this.handleResult(field, result, { validatorName, validator });\n                    }));\n                }\n                return this.handleResult(field, isValid, { validatorName, validator });\n            }\n            return isValid;\n        });\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @param {?} isValid\n     * @param {?} __2\n     * @return {?}\n     */\n    handleResult(field, isValid, { validatorName, validator }) {\n        if (isObject(validator) && field.formControl && validator.errorPath) {\n            /** @type {?} */\n            const control = field.formControl.get(validator.errorPath);\n            if (control) {\n                /** @type {?} */\n                const controlErrors = (control.errors || {});\n                if (!isValid) {\n                    control.setErrors(Object.assign({}, controlErrors, { [validatorName]: { message: validator.message } }));\n                }\n                else {\n                    delete controlErrors[validatorName];\n                    control.setErrors(Object.keys(controlErrors).length === 0 ? null : controlErrors);\n                }\n            }\n            return isValid ? null : { [validatorName]: { errorPath: validator.errorPath } };\n        }\n        return isValid ? null : { [validatorName]: true };\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * \\@experimental\n */\nclass FieldFormExtension {\n    /**\n     * @param {?} config\n     */\n    constructor(config) {\n        this.config = config;\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n    onPopulate(field) {\n        if (field.key) {\n            this.addFormControl(field);\n        }\n        if (field.parent && field.fieldGroup && !field.key) {\n            defineHiddenProp(field, 'formControl', field.parent.formControl);\n        }\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n    postPopulate(field) {\n        if (field.parent) {\n            return;\n        }\n        /** @type {?} */\n        const updateValidity = this.setValidators(field);\n        updateValidity && ((/** @type {?} */ (field.formControl)))._updateTreeValidity();\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n    addFormControl(field) {\n        /** @type {?} */\n        let control = findControl(field);\n        if (!control) {\n            /** @type {?} */\n            const controlOptions = { updateOn: field.modelOptions.updateOn };\n            /** @type {?} */\n            const value = getFieldValue(field);\n            /** @type {?} */\n            const ref = this.config ? this.config.resolveFieldTypeRef(field) : null;\n            if (ref && ref.componentType && ref.componentType['createControl']) {\n                /** @type {?} */\n                const component = ref.componentType;\n                console.warn(`NgxFormly: '${component.name}::createControl' is deprecated since v5.0, use 'prePopulate' hook instead.`);\n                control = component['createControl'](value, field);\n            }\n            else if (field.fieldGroup) {\n                // TODO: move to postPopulate\n                control = new FormGroup({}, controlOptions);\n            }\n            else {\n                control = new FormControl(value, controlOptions);\n            }\n        }\n        registerControl(field, control);\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n    setValidators(field) {\n        /** @type {?} */\n        let updateValidity = false;\n        if (field.key) {\n            const { formControl: c, templateOptions: { disabled }, } = field;\n            if (disabled && c.enabled) {\n                c.disable({ emitEvent: false, onlySelf: true });\n                updateValidity = true;\n            }\n            if (null === c.validator || null === c.asyncValidator) {\n                c.setValidators((/**\n                 * @return {?}\n                 */\n                () => {\n                    /** @type {?} */\n                    const fields = c['_fields'].length === 1\n                        ? c['_fields']\n                        : c['_fields'].filter((/**\n                         * @param {?} f\n                         * @return {?}\n                         */\n                        f => !f._hide));\n                    /** @type {?} */\n                    const v = Validators.compose(fields.map((/**\n                     * @param {?} f\n                     * @return {?}\n                     */\n                    f => f._validators)));\n                    return v ? v(c) : null;\n                }));\n                c.setAsyncValidators((/**\n                 * @return {?}\n                 */\n                () => {\n                    /** @type {?} */\n                    const fields = c['_fields'].length === 1\n                        ? c['_fields']\n                        : c['_fields'].filter((/**\n                         * @param {?} f\n                         * @return {?}\n                         */\n                        f => !f._hide));\n                    /** @type {?} */\n                    const v = Validators.composeAsync(fields.map((/**\n                     * @param {?} f\n                     * @return {?}\n                     */\n                    f => f._asyncValidators)));\n                    return v ? v(c) : of(null);\n                }));\n                if (!c.parent) {\n                    c.updateValueAndValidity({ emitEvent: false });\n                }\n                else {\n                    updateValidity = true;\n                }\n            }\n        }\n        (field.fieldGroup || []).forEach((/**\n         * @param {?} f\n         * @return {?}\n         */\n        f => this.setValidators(f) && (updateValidity = true)));\n        return updateValidity;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * \\@experimental\n */\nclass CoreExtension {\n    /**\n     * @param {?} formlyConfig\n     */\n    constructor(formlyConfig) {\n        this.formlyConfig = formlyConfig;\n        this.formId = 0;\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n    prePopulate(field) {\n        this.getFieldComponentInstance(field).prePopulate();\n        if (field.parent) {\n            return;\n        }\n        /** @type {?} */\n        const fieldTransforms = (field.options && field.options.fieldTransform) || this.formlyConfig.extras.fieldTransform;\n        (Array.isArray(fieldTransforms) ? fieldTransforms : [fieldTransforms]).forEach((/**\n         * @param {?} fieldTransform\n         * @return {?}\n         */\n        fieldTransform => {\n            if (fieldTransform) {\n                console.warn(`NgxFormly: fieldTransform is deprecated since v5.0, use custom extension instead.`);\n                /** @type {?} */\n                const fieldGroup = fieldTransform(field.fieldGroup, field.model, (/** @type {?} */ (field.formControl)), field.options);\n                if (!fieldGroup) {\n                    throw new Error('fieldTransform must return an array of fields');\n                }\n            }\n        }));\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n    onPopulate(field) {\n        this.initFieldOptions(field);\n        this.getFieldComponentInstance(field).onPopulate();\n        if (field.fieldGroup) {\n            field.fieldGroup.forEach((/**\n             * @param {?} f\n             * @param {?} index\n             * @return {?}\n             */\n            (f, index) => {\n                Object.defineProperty(f, 'parent', { get: (/**\n                     * @return {?}\n                     */\n                    () => field), configurable: true });\n                Object.defineProperty(f, 'index', { get: (/**\n                     * @return {?}\n                     */\n                    () => index), configurable: true });\n                this.formId++;\n            }));\n        }\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n    postPopulate(field) {\n        this.getFieldComponentInstance(field).postPopulate();\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n    initFieldOptions(field) {\n        /** @type {?} */\n        const root = (/** @type {?} */ (field.parent));\n        if (!root) {\n            return;\n        }\n        Object.defineProperty(field, 'form', { get: (/**\n             * @return {?}\n             */\n            () => root.formControl), configurable: true });\n        Object.defineProperty(field, 'options', { get: (/**\n             * @return {?}\n             */\n            () => root.options), configurable: true });\n        Object.defineProperty(field, 'model', {\n            get: (/**\n             * @return {?}\n             */\n            () => field.key && field.fieldGroup ? getFieldValue(field) : root.model),\n            configurable: true,\n        });\n        reverseDeepMerge(field, {\n            id: getFieldId(`formly_${this.formId}`, field, field['index']),\n            hooks: {},\n            modelOptions: {},\n            templateOptions: !field.type || !field.key ? {} : {\n                label: '',\n                placeholder: '',\n                focus: false,\n                disabled: false,\n            },\n        });\n        if (field.lifecycle) {\n            console.warn(`NgxFormly: 'lifecycle' is deprecated since v5.0, use 'hooks' instead.`);\n        }\n        if (field.type !== 'formly-template'\n            && (field.hasOwnProperty('template')\n                || (field.expressionProperties && field.expressionProperties.template))) {\n            if (field.type) {\n                console.warn(`NgxFormly: passing 'type' property is not allowed when 'template' is set.`);\n            }\n            field.type = 'formly-template';\n        }\n        if (!field.type && field.fieldGroup) {\n            field.type = 'formly-group';\n        }\n        if (field.type) {\n            this.formlyConfig.getMergedField(field);\n        }\n        if (!field['autoClear'] && !isUndefined(field.defaultValue) && isUndefined(getFieldValue(field))) {\n            assignModelValue(root.model, getKeyPath(field), field.defaultValue);\n        }\n        this.initFieldWrappers(field);\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n    initFieldWrappers(field) {\n        field.wrappers = field.wrappers || [];\n        /** @type {?} */\n        const fieldTemplateManipulators = Object.assign({ preWrapper: [], postWrapper: [] }, (field.templateOptions.templateManipulators || {}));\n        field.wrappers = [\n            ...this.formlyConfig.templateManipulators.preWrapper.map((/**\n             * @param {?} m\n             * @return {?}\n             */\n            m => m(field))),\n            ...fieldTemplateManipulators.preWrapper.map((/**\n             * @param {?} m\n             * @return {?}\n             */\n            m => m(field))),\n            ...field.wrappers,\n            ...this.formlyConfig.templateManipulators.postWrapper.map((/**\n             * @param {?} m\n             * @return {?}\n             */\n            m => m(field))),\n            ...fieldTemplateManipulators.postWrapper.map((/**\n             * @param {?} m\n             * @return {?}\n             */\n            m => m(field))),\n        ].filter((/**\n         * @param {?} el\n         * @param {?} i\n         * @param {?} a\n         * @return {?}\n         */\n        (el, i, a) => el && i === a.indexOf(el)));\n    }\n    /**\n     * @private\n     * @param {?} field\n     * @return {?}\n     */\n    getFieldComponentInstance(field) {\n        /** @type {?} */\n        const componentRef = this.formlyConfig.resolveFieldTypeRef(field);\n        /** @type {?} */\n        const instance = componentRef ? (/** @type {?} */ (componentRef.instance)) : {};\n        return {\n            prePopulate: (/**\n             * @return {?}\n             */\n            () => instance.prePopulate && instance.prePopulate(field)),\n            onPopulate: (/**\n             * @return {?}\n             */\n            () => instance.onPopulate && instance.onPopulate(field)),\n            postPopulate: (/**\n             * @return {?}\n             */\n            () => instance.postPopulate && instance.postPopulate(field)),\n        };\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} formlyConfig\n * @return {?}\n */\nfunction defaultFormlyConfig(formlyConfig) {\n    return {\n        types: [\n            { name: 'formly-group', component: FormlyGroup },\n            { name: 'formly-template', component: FormlyTemplateType },\n        ],\n        extensions: [\n            { name: 'core', extension: new CoreExtension(formlyConfig) },\n            { name: 'field-validation', extension: new FieldValidationExtension(formlyConfig) },\n            { name: 'field-form', extension: new FieldFormExtension(formlyConfig) },\n            { name: 'field-expression', extension: new FieldExpressionExtension() },\n        ],\n    };\n}\nclass FormlyModule {\n    /**\n     * @param {?} configService\n     * @param {?=} configs\n     */\n    constructor(configService, configs = []) {\n        if (!configs) {\n            return;\n        }\n        configs.forEach((/**\n         * @param {?} config\n         * @return {?}\n         */\n        config => configService.addConfig(config)));\n    }\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n    static forRoot(config = {}) {\n        return {\n            ngModule: FormlyModule,\n            providers: [\n                { provide: FORMLY_CONFIG, multi: true, useFactory: defaultFormlyConfig, deps: [FormlyConfig] },\n                { provide: FORMLY_CONFIG, useValue: config, multi: true },\n                { provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: config, multi: true },\n                FormlyConfig,\n                FormlyFormBuilder,\n            ],\n        };\n    }\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n    static forChild(config = {}) {\n        return {\n            ngModule: FormlyModule,\n            providers: [\n                { provide: FORMLY_CONFIG, useValue: config, multi: true },\n                { provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: config, multi: true },\n                FormlyFormBuilder,\n            ],\n        };\n    }\n}\nFormlyModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    FormlyForm,\n                    FormlyField,\n                    FormlyAttributes,\n                    FormlyGroup,\n                    FormlyValidationMessage,\n                    FormlyTemplateType,\n                ],\n                entryComponents: [FormlyGroup, FormlyTemplateType],\n                exports: [FormlyForm, FormlyField, FormlyAttributes, FormlyGroup, FormlyValidationMessage],\n                imports: [CommonModule],\n            },] }\n];\n/** @nocollapse */\nFormlyModule.ctorParameters = () => [\n    { type: FormlyConfig },\n    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [FORMLY_CONFIG,] }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { FormlyForm, FormlyField, FormlyAttributes, FORMLY_CONFIG, FormlyConfig, FormlyFormBuilder, FieldType, Field, FieldArrayType, FieldWrapper, FormlyModule, defineHiddenProp as defineHiddenProp, reverseDeepMerge as reverseDeepMerge, getFieldInitialValue as getFieldInitialValue, defaultFormlyConfig as a, CoreExtension as e, FieldExpressionExtension as h, FieldFormExtension as g, FieldValidationExtension as f, FormlyTemplateType as d, FormlyGroup as b, FormlyValidationMessage as c };\n"]}